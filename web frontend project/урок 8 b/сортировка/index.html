<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorts</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="title">
        <div>
        <h1 class="title-text">WFD-book</h1>
        </div>
            </div>
    <div class="sort-1">
        <h1>сортировка пузырьком</h1>
     <p>Сортиро́вка простыми обменами, сортировка пузырько́м (англ. bubble sort) — простой алгоритм сортировки. Для понимания и реализации этот алгоритм — простейший, но эффективен он лишь для небольших массивов. Сложность алгоритма: {\displaystyle O}O{\displaystyle (n^{2})}(n^{2}).
        Алгоритм считается учебным и практически не применяется вне учебной литературы, вместо него на практике применяются более эффективные алгоритмы сортировки. В то же время метод сортировки обменами лежит в основе некоторых более совершенных алгоритмов, таких как шейкерная сортировка, пирамидальная сортировка и быстрая сортировка.
        </p>   
                                
       <p>
        <p>    ЦИКЛ ДЛЯ J=1 ДО N-1 ШАГ 1</p>
        <p>   FOR J=1 TO N-1 STEP 1 </p>
        <p>   F=0     </p>                                        F=0</p>
        <p>  ЦИКЛ ДЛЯ I=0 ДО N-1-J ШАГ 1   </p>                  FOR I=0 TO N-1-J STEP 1</p>
        <p>     ЕСЛИ A[I] > A[I+1] ТО ОБМЕН A[I],A[I+1]:F=1 </p>    IF A[I]>A[I+1] THEN SWAP A[I],A[I+1]:F=1</p>
        <p>   СЛЕДУЮЩЕЕ I                 </p>                    NEXT I</p>
        <p>   ЕСЛИ F=0 ТО ВЫХОД ИЗ ЦИКЛА    </p>                  IF F=0 THEN EXIT FOR</p>
        <p>  СЛЕДУЮЩЕЕ J     </p>                                NEXT J</p>
    </p> 
    </div>
    <div class="sort-2">
        <h1>Сортировка слиянием</h1>
    <p>Сортировка слиянием (англ. merge sort) — алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке. Эта сортировка — хороший пример использования принципа «разделяй и властвуй». Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Наконец, их решения комбинируются, и получается решение исходной задачи.
        Сортируемый массив разбивается на две части примерно одинакового размера;
Каждая из получившихся частей сортируется отдельно, например — тем же самым алгоритмом;
Два упорядоченных массива половинного размера соединяются в один.
1.1. — 2.1. Рекурсивное разбиение задачи на меньшие происходит до тех пор, пока размер массива не достигнет единицы (любой массив длины 1 можно считать упорядоченным).

3.1. Соединение двух упорядоченных массивов в один.
Основную идею слияния двух отсортированных массивов можно объяснить на следующем примере. Пусть мы имеем два уже отсортированных по возрастанию подмассива. Тогда:
3.2. Слияние двух подмассивов в третий результирующий массив.
На каждом шаге мы берём меньший из двух первых элементов подмассивов и записываем его в результирующий массив. Счётчики номеров элементов результирующего массива и подмассива, из которого был взят элемент, увеличиваем на 1.
3.4. «Прицепление» остатка.
Когда один из подмассивов закончился, мы добавляем все оставшиеся элементы второго подмассива в результирующий массив.

Пример сортировки на языке С
    </p>
    <p> <h2> пример кода сортировки слиянием на языке java-script</h2>
<div class="code-bk"><p>const merge = (arrFirst, arrSecond) => {    const arrSort = [];    let i = j = 0;    // сравниваем два массива, поочередно сдвигая указатели    while (i < arrFirst.length && j < arrSecond.length) {        arrSort.push(            (arrFirst[i] < arrSecond[j]) ?                arrFirst[i++] : arrSecond[j++]        );    }    // обрабатываем последний элемент при разной длине массивов    // и возвращаем один отсортированный массив    return [        ...arrSort,        ...arrFirst.slice(i),        ...arrSecond.slice(j)    ];};
    const mergeSort = arr => {    // Проверяем корректность переданных данных    if (!arr || !arr.length) {        return null;    }    //Если массив содержит один элемент просто возвращаем его    if (arr.length <= 1) {        return arr;    }    // Находим середину массива и делим его на два    const middle = Math.floor(arr.length / 2);    const arrLeft = arr.slice(0, middle);    const arrRight = arr.slice(middle);    // Для новых массивов снова вызываем сортировку,    // сливаем их и возвращаем снова единый массив    return merge(mergeSort(arrLeft), mergeSort(arrRight));;};
     </p></div>



    </p>
    </div>
    <div class="sort-3">
        <h1>Сортировка вставками</h1>
<p>Создадим массив, в котором после завершения алгоритма будет лежать ответ. Будем поочередно вставлять элементы из исходного массива так, чтобы элементы в массиве-ответе всегда были отсортированы. Асимптотика в среднем и худшем случае – O(n2), в лучшем – O(n). Реализовывать алгоритм удобнее по-другому (создавать новый массив и реально что-то вставлять в него относительно сложно): просто сделаем так, чтобы отсортирован был некоторый префикс исходного массива, вместо вставки будем менять текущий элемент с предыдущим, пока они стоят в неправильном порядке.</p>
    </div>
</body>
</html>